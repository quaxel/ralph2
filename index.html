<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Dice Roller</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1a1a2e;
            color: white;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            padding: 2rem;
            box-sizing: border-box;
        }

        header {
            text-align: center;
            pointer-events: auto;
            background: rgba(0, 0, 0, 0.5);
            padding: 1rem 2rem;
            border-radius: 12px;
            backdrop-filter: blur(5px);
        }

        h1 {
            margin: 0;
            font-size: 2rem;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        #result-display {
            font-size: 1.5rem;
            margin-top: 0.5rem;
            font-weight: bold;
            color: #4cc9f0;
        }

        #controls {
            pointer-events: auto;
            margin-bottom: 2rem;
        }

        button {
            background: #4cc9f0;
            color: #1a1a2e;
            border: none;
            padding: 1rem 2rem;
            font-size: 1.2rem;
            font-weight: bold;
            border-radius: 50px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 4px 15px rgba(76, 201, 240, 0.4);
        }

        button:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(76, 201, 240, 0.6);
        }

        button:active {
            transform: scale(0.95);
        }

        button:disabled {
            background: #555;
            cursor: not-allowed;
            box-shadow: none;
        }
    </style>
</head>
<body>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <header>
            <h1>3D Dice Roller</h1>
            <div id="result-display">Ready to roll</div>
        </header>
        
        <div id="controls">
            <button id="roll-btn">ROLL DICE</button>
        </div>
    </div>

    <!-- Three.js CDN -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { RoundedBoxGeometry } from 'three/addons/geometries/RoundedBoxGeometry.js';

        // --- Configuration ---
        const DICE_SIZE = 1;
        const ANIMATION_DURATION = 1000; // ms
        const ROLL_COUNT = 20; // Number of rotations per axis

        // --- State ---
        let scene, camera, renderer, controls;
        let die;
        let isRolling = false;
        
        // --- Initialization ---
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);
            scene.fog = new THREE.Fog(0x1a1a2e, 5, 20);

            // Camera
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(4, 3, 5);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 1);
            dirLight.position.set(5, 10, 7);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 1024;
            dirLight.shadow.mapSize.height = 1024;
            scene.add(dirLight);

            // Floor
            const floorGeometry = new THREE.PlaneGeometry(20, 20);
            const floorMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x16213e, 
                roughness: 0.8,
                metalness: 0.2
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            // Grid Helper
            const gridHelper = new THREE.GridHelper(20, 20, 0x4cc9f0, 0x0f3460);
            scene.add(gridHelper);

            // Create Die
            createDie();

            // Event Listeners
            window.addEventListener('resize', onWindowResize);
            document.getElementById('roll-btn').addEventListener('click', rollDice);

            // Start Loop
            animate();
        }

        function createDie() {
            // Geometry
            const geometry = new RoundedBoxGeometry(DICE_SIZE, DICE_SIZE, DICE_SIZE, 4, 0.1);

            // Materials (One for each face)
            // Order: Right, Left, Top, Bottom, Front, Back
            const materials = [
                new THREE.MeshStandardMaterial({ color: 0xffffff }), // Right
                new THREE.MeshStandardMaterial({ color: 0xffffff }), // Left
                new THREE.MeshStandardMaterial({ color: 0xffffff }), // Top
                new THREE.MeshStandardMaterial({ color: 0xffffff }), // Bottom
                new THREE.MeshStandardMaterial({ color: 0xffffff }), // Front
                new THREE.MeshStandardMaterial({ color: 0xffffff }), // Back
            ];

            die = new THREE.Mesh(geometry, materials);
            die.castShadow = true;
            die.receiveShadow = true;
            die.position.y = DICE_SIZE / 2;
            scene.add(die);

            // Add Pips (Dots)
            addPips(die);
        }

        function addPips(dieMesh) {
            const pipGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.05, 16);
            const pipMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });

            // Helper to add a pip at local position
            const addPip = (x, y, z) => {
                const pip = new THREE.Mesh(pipGeometry, pipMaterial);
                pip.position.set(x, y, z);
                dieMesh.add(pip);
            };

            // Face 1 (Top)
            addPip(0, DICE_SIZE/2 + 0.06, 0);

            // Face 2 (Bottom)
            addPip(-DICE_SIZE/2 + 0.1, -DICE_SIZE/2 + 0.06, 0);
            addPip(DICE_SIZE/2 - 0.1, -DICE_SIZE/2 + 0.06, 0);

            // Face 3 (Front)
            addPip(-DICE_SIZE/2 + 0.1, 0, DICE_SIZE/2 + 0.06);
            addPip(0, 0, DICE_SIZE/2 + 0.06);
            addPip(DICE_SIZE/2 - 0.1, 0, DICE_SIZE/2 + 0.06);

            // Face 4 (Back)
            addPip(-DICE_SIZE/2 + 0.1, -DICE_SIZE/2 + 0.06, -DICE_SIZE/2 + 0.06);
            addPip(DICE_SIZE/2 - 0.1, -DICE_SIZE/2 + 0.06, -DICE_SIZE/2 + 0.06);
            addPip(-DICE_SIZE/2 + 0.1, DICE_SIZE/2 + 0.06, -DICE_SIZE/2 + 0.06);
            addPip(DICE_SIZE/2 - 0.1, DICE_SIZE/2 + 0.06, -DICE_SIZE/2 + 0.06);

            // Face 5 (Left)
            addPip(-DICE_SIZE/2 + 0.1, -DICE_SIZE/2 + 0.06, 0);
            addPip(DICE_SIZE/2 - 0.1, -DICE_SIZE/2 + 0.06, 0);
            addPip(-DICE_SIZE/2 + 0.1, 0, 0);
            addPip(DICE_SIZE/2 - 0.1, 0, 0);
            addPip(-DICE_SIZE/2 + 0.1, DICE_SIZE/2 + 0.06, 0);

            // Face 6 (Right)
            addPip(-DICE_SIZE/2 + 0.1, -DICE_SIZE/2 + 0.06, 0);
            addPip(DICE_SIZE/2 - 0.1, -DICE_SIZE/2 + 0.06, 0);
            addPip(-DICE_SIZE/2 + 0.1, 0, 0);
            addPip(DICE_SIZE/2 - 0.1, 0, 0);
            addPip(-DICE_SIZE/2 + 0.1, DICE_SIZE/2 + 0.06, 0);
            addPip(DICE_SIZE/2 - 0.1, DICE_SIZE/2 + 0.06, 0);
        }

        function rollDice() {
            if (isRolling) return;
            isRolling = true;
            document.getElementById('roll-btn').disabled = true;
            document.getElementById('result-display').innerText = "Rolling...";

            // Calculate random rotation
            // We rotate around all axes
            const rotX = Math.PI * 2 * ROLL_COUNT + (Math.random() * Math.PI * 2);
            const rotY = Math.PI * 2 * ROLL_COUNT + (Math.random() * Math.PI * 2);
            const rotZ = Math.PI * 2 * ROLL_COUNT + (Math.random() * Math.PI * 2);

            // Calculate random position (bounce effect)
            const targetY = DICE_SIZE / 2;
            const targetX = (Math.random() - 0.5) * 1.5;
            const targetZ = (Math.random() - 0.5) * 1.5;

            // Simple animation using requestAnimationFrame for control
            const startTime = performance.now();
            const startRot = die.rotation.clone();
            const startPos = die.position.clone();

            function animateRoll(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / ANIMATION_DURATION, 1);

                // Ease out cubic
                const ease = 1 - Math.pow(1 - progress, 3);

                die.rotation.x = startRot.x + (rotX - startRot.x) * ease;
                die.rotation.y = startRot.y + (rotY - startRot.y) * ease;
                die.rotation.z = startRot.z + (rotZ - startRot.z) * ease;

                die.position.y = startPos.y + (targetY - startPos.y) * ease;
                die.position.x = startPos.x + (targetX - startPos.x) * ease;
                die.position.z = startPos.z + (targetZ - startPos.z) * ease;

                if (progress < 1) {
                    requestAnimationFrame(animateRoll);
                } else {
                    isRolling = false;
                    document.getElementById('roll-btn').disabled = false;
                    document.getElementById('result-display').innerText = "Result: " + getFaceValue();
                }
            }

            requestAnimationFrame(animateRoll);
        }

        function getFaceValue() {
            // Determine which face is pointing up based on rotation
            // This is a simplified approximation for a standard die
            // We normalize rotations to 0-2PI
            
            const rx = die.rotation.x % (Math.PI * 2);
            const ry = die.rotation.y % (Math.PI * 2);
            const rz = die.rotation.z % (Math.PI * 2);

            // Normalize to positive values
            const normRx = rx < 0 ? rx + Math.PI * 2 : rx;
            const normRy = ry < 0 ? ry + Math.PI * 2 : ry;
            const normRz = rz < 0 ? rz + Math.PI * 2 : rz;

            // Logic to determine face based on standard die orientation
            // Top face is usually 1. 
            // If Top is 1, Bottom is 6.
            // We check the rotation of the Top face (0, 1, 0) and Bottom face (0, -1, 0)
            
            // Simplified logic: Check which face normal is closest to (0, 1, 0) (Up)
            // Or simply check the rotation of the Top face.
            
            // Let's use a simpler heuristic based on the rotation values
            // This is a common trick for dice in Three.js
            
            // Normalize angles to 0-PI
            const rX = Math.abs(normRx % Math.PI);
            const rY = Math.abs(normRy % Math.PI);
            const rZ = Math.abs(normRz % Math.PI);

            // Determine Top Face
            // If Top is 1, it faces +Y. 
            // If Top is 6, it faces -Y.
            
            // We check the rotation of the Top face (0, 1, 0)
            // If the rotation of the Top face is close to 0, it's 1.
            // If the rotation of the Top face is close to PI, it's 6.
            
            // Let's use a lookup based on the rotation of the Top face (0, 1, 0)
            // The Top face is at local (0, 1, 0).
            // We rotate the vector (0, 1, 0) by the die's rotation.
            
            const upVector = new THREE.Vector3(0, 1, 0);
            upVector.applyEuler(die.rotation);
            
            // The face value is determined by which face normal aligns with the world Up vector (0, 1, 0)
            // or world Down vector (0, -1, 0).
            
            // Let's check the dot product with World Up and World Down
            const dotUp = Math.abs(upVector.dot(new THREE.Vector3(0, 1, 0)));
            const dotDown = Math.abs(upVector.dot(new THREE.Vector3(0, -1, 0)));
            
            if (dotUp > 0.9) return 1;
            if (dotDown > 0.9) return 6;
            
            // Check Front/Back
            const frontVector = new THREE.Vector3(0, 0, 1);
            frontVector.applyEuler(die.rotation);
            const dotFront = Math.abs(frontVector.dot(new THREE.Vector3(0, 0, 1)));
            const dotBack = Math.abs(frontVector.dot(new THREE.Vector3(0, 0, -1)));
            
            if (dotFront > 0.9) return 3;
            if (dotBack > 0.9) return 4;
            
            // Check Left/Right
            const leftVector = new THREE.Vector3(-1, 0, 0);
            leftVector.applyEuler(die.rotation);
            const dotLeft = Math.abs(leftVector.dot(new THREE.Vector3(-1, 0, 0)));
            const dotRight = Math.abs(leftVector.dot(new THREE.Vector3(1, 0, 0)));
            
            if (dotLeft > 0.9) return 2;
            if (dotRight > 0.9) return 5;
            
            return "?";
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // Start
        init();
    </script>
</body>
</html>
